# frozen_string_literal: true

module TestSupport::AssertionsHelper
  def capture_log_output(&)
    output = StringIO.new
    logger = Logger.new(output)

    previous_logger = ActiveRecord::Base.logger
    ActiveRecord::Base.logger = logger
    yield output
  ensure
    ActiveRecord::Base.logger = previous_logger
  end

  def capture_sql_log
    output = nil
    capture_log_output do |captured|
      yield
      output = captured.string
    end
    output
  end

  # Assert that the SQL generated by the block has expected counts of things
  # Performs simple grepping, so can be fooled with adversarial string input values.
  #
  # values: true/false/Integer - whether a VALUES table is present, and if so how many columns it has
  # on_width: Integer - how many conditions are in the ON clause. there should be only one ON clause.
  # cases: Integer - how many CASE expressions are present
  # whens: Integer - how many WHEN conditions are present
  #
  def assert_query_sql(values: nil, on_width: nil, cases: nil, whens: nil, &block)
    sql_log = capture_sql_log(&block)

    unless values.nil?
      values_width = values_table_column_width(sql_log)
      case values
      when true
        assert values_width > 0, "Expected a VALUES table, but none found:\n#{sql_log}"
      when false
        assert_equal 0, values_width, "Expected no VALUES table, but one was found:\n#{sql_log}"
      when Integer
        assert_equal values, values_width, "Unexpected number of columns in VALUES table:\n#{sql_log}"
      else
        raise ArgumentError, "Expected :values to be true/false/Integer, got #{values.inspect}"
      end
    end

    unless on_width.nil?
      on_count = sql_log.scan(/ ON /).size
      assert_equal on_width > 0 ? 1 : 0, on_count, "Expected exactly one ON clause, but found #{on_count}:\n#{sql_log}"

      unless on_width == 0
        on_clause = sql_log[/ ON (.*?)(?: (?:JOIN|SET|WHERE|VALUES|UNION)|\z)/m, 1]
        actual_width = 1 + on_clause.scan(/ AND /).size
        assert_equal on_width, actual_width, "Unexpected number of conditions in ON clause:\n#{sql_log}"
      end
    end

    unless cases.nil?
      assert_equal cases, sql_log.scan(/[ (]CASE /).size, "Unexpected number of CASE expressions:\n#{sql_log}"
    end

    unless whens.nil?
      assert_equal whens, sql_log.scan(/ WHEN /).size, "Unexpected number of WHEN conditions:\n#{sql_log}"
    end
  end

  # Compact model-delta format:
  # {
  #   1 => { name: "Updated", updated_at: :_modified },         # update
  #   2 => :deleted,                                            # delete
  #   9 => :created                                             # insert
  # }
  # For composite PK tables, keys are arrays: ["Toyota", "Camry"].
  # To not bother specifying new values (e.g. timestamps), use :_modified.
  def assert_model_snapshot_delta(model, original, actual, differences)
    expected = original.dup # dup rows only when needed for performance
    attribute_keys = model.column_names

    differences.each do |id, spec|
      case spec
      when :deleted
        assert_not_nil original[id], "Expected row #{id.inspect} to be deleted, but it never existed"
        assert_nil actual[id], "Expected row #{id.inspect} to be deleted, but it still exists"
        expected.delete(id)
      when :created
        assert_nil original[id], "Expected row #{id.inspect} to be created, but it already existed"
        assert_not_nil actual[id], "Expected row #{id.inspect} to be created, but it no longer exists"
        expected[id] = actual.fetch(id)
      when Hash
        assert_not_nil original[id], "Expected row #{id.inspect} to be updated, but it never existed"
        assert_not_nil actual[id], "Expected row #{id.inspect} to be updated, but it no longer exists"
        row = expected[id] = expected.fetch(id).dup

        spec.transform_keys(&:to_s).each do |key, value|
          value = actual.fetch(id).fetch(key) if value == :_modified
          assert_includes attribute_keys, key, "Unknown attribute #{key.inspect}"
          assert_not_equal row[key], value, "Expected row #{id.inspect}.#{key} to have a new value, but it is equal to the old value: #{value.inspect}"

          row[key] = value
        end
      else
        raise ArgumentError, "Invalid spec #{spec.inspect}"
      end
    end

    assert_empty actual.keys - expected.keys, "Found unexpected created rows"
    assert_empty expected.keys - actual.keys, "Found unexpected deleted rows"

    diff = compute_grouped_shallow_json_diffs(expected, actual)
    assert_empty diff, "Unexpected delta for #{model.name}"
  end

  def snapshot_model(model)
    primary_key = Array.wrap(model.primary_key)
    model.all.sort_by(&:id).index_by(&:id).transform_values! do |record|
      record.attributes.except(*primary_key).freeze
    end.freeze
  end

  def values_table_column_width(sql_log)
    sql = sql_log[/[ (]VALUES (.*)/, 1]
    return count_values_columns(sql) if sql

    sql = sql_log[/ JOIN \(SELECT (.*?(?:FROM|SET|ON|WHERE|VALUES|UNION))/, 1]
    sql ? count_select_columns(sql) : 0
  end

  # Count columns in a SELECT projection (text after 'SELECT ...')
  def count_select_columns(projection)
    d = 0; q = nil; n = 1
    projection.each_char do |c|
      if q then q = nil if c == q
      elsif c == "'" || c == '"' then q = c
      elsif c == "(" then d += 1
      elsif c == ")" then d -= 1
      elsif c == "," && d == 0 then n += 1
      end
      break if d < 0
    end
    n
  end

  # Count columns in a VALUES row, e.g. "VALUES (1,'a',now()), (2,'b',now())"
  def count_values_columns(values)
    i = values.index("(")
    d = 0; q = nil; n = 1
    values[i..].each_char do |c|
      if q then q = nil if c == q
      elsif c == "'" || c == '"' then q = c
      elsif c == "(" then d += 1
      elsif c == ")" then d -= 1; break if d <= 0
      elsif c == "," && d == 1 then n += 1
      end
    end
    n
  end

  def compute_shallow_json_diff(lhs, rhs)
    diffs = {}
    all_keys = lhs.keys | rhs.keys
    all_keys.each do |k|
      diffs[k] = [lhs[k], rhs[k]] if lhs.fetch(k) != rhs.fetch(k)
    end
    diffs
  end

  def compute_grouped_shallow_json_diffs(lhs, rhs)
    diffs = {}
    all_ids = lhs.keys & rhs.keys
    all_ids.each do |id|
      diffs[id] = compute_shallow_json_diff(lhs[id], rhs[id]) if lhs[id] != rhs[id]
    end
    diffs
  end

  def check_constraint_violation_type
    case ActiveRecord::Base.connection.adapter_name
    when "PostgreSQL"
      ActiveRecord::StatementInvalid
    else
      ActiveRecord::CheckViolation
    end
  end

  def value_too_long_violation_type
    case ActiveRecord::Base.connection.adapter_name
    when "SQLite"
      ActiveRecord::CheckViolation
    when "Mysql2", "Trilogy"
      ActiveRecord::StatementInvalid
    else
      ActiveRecord::ValueTooLong
    end
  end
end
